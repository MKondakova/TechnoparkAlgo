#Курс по алгоритмам и структурам данных в технопарке

---
##Модуль 1
###Задача 1. “Считалочка”
В круг выстроено N человек, пронумерованных числами от 1 до N. Будем исключать каждого k-ого до тех пор, пока не уцелеет только один человек. (Например, если N=10, k=3, то сначала умрет 3-й, потом 6-й, затем 9-й, затем 2-й, затем 7-й, потом 1-й, потом 8-й, за ним - 5-й, и потом 10-й. Таким образом, уцелеет 4-й.) Необходимо определить номер уцелевшего.
N, k ≤ 10000.

Требования:  Решить перебором.

in | out
--- | ---
10 | 3
5 5 | 2
###Задача 2.
Дан отсортированный массив различных целых чисел A[0..n-1] и массив целых чисел B[0..m-1]. Для каждого элемента массива B[i] найдите минимальный индекс элемента массива A[k], ближайшего по значению к B[i].

Требования: Время работы поиска для каждого элемента B[i]: O(log(k)). 

Внимание! В этой задаче для каждого B[i] сначала нужно определить диапазон для бинарного поиска размером порядка k, а потом уже в нем делать бинарный поиск.
n ≤ 110000, m ≤ 1000.

in | out
--- | ---
3<br>10 20 30<br>3<br>9 15 35 | 0 0 2
3<br>10 20 30<br>4<br>8 9 10 32 | 0 0 0 2
###Задача 3.
Реализовать дек с динамическим зацикленным буфером.

_Формат входных данных._
В первой строке количество команд n. n ≤ 1000000.
Каждая команда задаётся как 2 целых числа: a b.
* a = 1 - push front
* a = 2 - pop front
* a = 3 - push back
* a = 4 - pop back

Команды добавления элемента 1 и 3 заданы с неотрицательным параметром b.
Если дана команда pop*, то число b - ожидаемое значение. Если команда pop вызвана для пустой структуры данных, то ожидается “-1”.
_Формат выходных данных._
Требуется напечатать YES - если все ожидаемые значения совпали. Иначе, если хотя бы одно ожидание не оправдалось, то напечатать NO.
###Задача 4. “Скользящий максимум”

Решение предполагает использование кучи, реализованной в виде класса. Решение должно поддерживать передачу функции сравнения снаружи.
Куча должна быть динамической.

Дан массив натуральных чисел A[0..n), n не превосходит 10^8. Так же задан размер некоторого окна (последовательно расположенных элементов массива) в этом массиве k, k<=n. Требуется для каждого положения окна (от 0 и до n-k) вывести значение максимума в окне.

Требования: Скорость работы O(n log n), память O(n).

_Формат входных данных._ Вначале вводится n - количество элементов массива. Затем вводится n строк со значением каждого элемента. Затем вводится k  - размер окна.

_Формат выходных данных._ Разделенные пробелом значения максимумов для каждого положения окна.

in | out
--- | ---
3<br>1 2 3<br>2 | 2 3
9<br>0 7 3 8 4 5 10 4 6<br>4 | 8 8 8 10 10 10
###Задача 5. “Закраска прямой”
Необходимо реализовать и использовать сортировку слиянием.
Решение должно поддерживать передачу функции сравнения снаружи.
Общее время работы алгоритма O(n log n).

На числовой прямой окрасили N отрезков. Известны координаты левого и правого концов каждого отрезка (Li и Ri). Найти длину окрашенной части числовой прямой.

in | out
--- | ---
3<br>1 4<br>7 8<br>2 5<br> | 5
###Задача 6.
Даны неотрицательные целые числа n,k и массив целых чисел из [0..10^9] размера n. Требуется найти k-ю порядковую статистику. т.е. напечатать число, которое бы стояло на позиции с индексом k (0..n-1) в отсортированном массиве.

Требования: к дополнительной памяти: O(n). Среднее время работы: O(n). Должна быть отдельно выделенная функция partition. Рекурсия запрещена. Решение должно поддерживать передачу функции сравнения снаружи.

Реализуйте стратегию выбора опорного элемента “медиана трёх”. Функцию Partition реализуйте методом прохода двумя итераторами от конца массива к началу.

in | out
--- | ---
10 4<br>1 2 3 4 5 6 7 8 9 10 | 5
10 0<br>3 6 5 7 2 9 8 10 4 1 | 1
10 9<br>0 0 0 0 0 0 0 0 0 1  | 1
---
##Модуль 2
###Задача 1. “Хеш-таблица”
Реализуйте структуру данных типа “множество строк” на основе динамической хеш-таблицы с открытой адресацией. Хранимые строки непустые и состоят из строчных латинских букв.
Хеш-функция строки должна быть реализована с помощью вычисления значения многочлена методом Горнера.
Начальный размер таблицы должен быть равным 8-ми. Перехеширование выполняйте при добавлении элементов в случае, когда коэффициент заполнения таблицы достигает 3/4.

Структура данных должна поддерживать операции добавления строки в множество, удаления строки из множества и проверки принадлежности данной строки множеству.
Для разрешения коллизий используйте двойное хеширование.
Требования: В таблице запрещено хранение указателей на описатель элемента.

_Формат входных данных_
Каждая строка входных данных задает одну операцию над множеством. Запись операции состоит из типа операции и следующей за ним через пробел строки, над которой проводится операция.
Тип операции  – один из трех символов:
* \+  означает добавление данной строки в множество;
* \-  означает удаление  строки из множества;  
* \?  означает проверку принадлежности данной строки множеству.

При добавлении элемента в множество НЕ ГАРАНТИРУЕТСЯ, что он отсутствует в этом множестве. При удалении элемента из множества НЕ ГАРАНТИРУЕТСЯ, что он присутствует в этом множестве.

_Формат выходных данных_
Программа должна вывести для каждой операции одну из двух строк OK или FAIL, в зависимости от того, встречается ли данное слово в нашем множестве.

in | out
--- | ---
+ hello<br>+ bye<br>  ? bye<br>+ bye<br>- bye<br>  ? bye<br>  ? hello | OK<br>OK<br>OK<br>FAIL<br>OK<br>FAIL<br>OK
###Задача 2. “Порядок обхода”
Дано число N < 106 и последовательность целых чисел из [-231..231] длиной N.
Требуется построить бинарное дерево, заданное наивным порядком вставки.
Т.е., при добавлении очередного числа K в дерево с корнем root, если root→Key ≤ K, то узел K добавляется в правое поддерево root; иначе в левое поддерево root.

Требования: Рекурсия запрещена. Решение должно поддерживать передачу функции сравнения снаружи.

Выведите элементы в порядке pre-order (сверху вниз).

in | out
--- | ---
3<br>2 1 3 | 2 1 3
3<br>1 2 3 | 1 2 3
3<br>3 1 2 | 3 1 2
4<br>3 1 4 2 | 3 1 2 4
###Задача 3. “Декартово дерево”
Дано число N < 106 и последовательность пар целых чисел из [-231..231] длиной N.
Построить декартово дерево из N узлов, характеризующихся парами чисел {Xi, Yi}.
Каждая пара чисел {Xi, Yi} определяет ключ Xi и приоритет Yi в декартовом дереве.
Добавление узла в декартово дерево выполняйте второй версией алгоритма, рассказанного на лекции:

* При добавлении узла (x, y) выполняйте спуск по ключу до узла P с меньшим приоритетом. Затем разбейте найденное поддерево по ключу x так, чтобы в первом поддереве все ключи меньше x, а во втором больше или равны x. Получившиеся два дерева сделайте дочерними для нового узла (x, y). Новый узел вставьте на место узла P.

Построить также наивное дерево поиска по ключам Xi методом из задачи 2.

Вычислить количество узлов в самом широком слое декартового дерева и количество узлов в самом широком слое наивного дерева поиска. Вывести их разницу. Разница может быть отрицательна.

in | out
--- | ---
10<br>5 11<br>18 8<br>25 7<br>50 12<br>30 30<br>15 15<br>20 10<br>22 5<br>40 20<br>45 9 | 1
10<br>38 19<br>37 5<br>47 15<br>35 0<br>12 3<br>0 42<br>31 37<br>21 45<br>30 26<br>41 6 | 1
###Задача 4. “Использование АВЛ-дерева. Порядковые статистики”
Дано число N и N строк. Каждая строка содержит команду добавления или удаления натуральных чисел, а также запрос на получение k-ой порядковой статистики. Команда добавления числа A задается положительным числом A, команда удаления числа A задается отрицательным числом “-A”. Запрос на получение k-ой порядковой статистики задается числом k.
Требования: скорость выполнения запроса - O(log n).

in | out
--- | ---
5<br>40 0<br>10 1<br>4 1<br>-10 0<br>50 2 | 2 1 3
---
##Модуль 3
###Задача 1. “Представление графа”
Дан базовый интерфейс для представления ориентированного графа:
```c++
struct IGraph {
virtual ~IGraph() {}

	// Добавление ребра от from к to.
virtual void AddEdge(int from, int to) = 0;

	virtual int VerticesCount() const  = 0;

virtual std::vector<int> GetNextVertices(int vertex) const = 0;
virtual std::vector<int> GetPrevVertices(int vertex) const = 0;
};
```
Необходимо написать несколько реализаций интерфейса:
+ ListGraph, хранящий граф в виде массива списков смежности,
+ MatrixGraph, хранящий граф в виде матрицы смежности,
+ SetGraph, хранящий граф в виде массива хэш-таблиц/сбалансированных деревьев поиска,
+ ArcGraph, хранящий граф в виде одного массива пар {from, to}.

Также необходимо реализовать конструктор, принимающий const IGraph&. Такой конструктор должен скопировать переданный граф в создаваемый объект.
Для каждого класса создавайте отдельные .h и .cpp файлы.
Число вершин графа задается в конструкторе каждой реализации.
###Задача 2. “Количество различных путей”
Дан невзвешенный неориентированный граф. В графе может быть несколько кратчайших путей между какими-то вершинами. Найдите количество различных кратчайших путей между заданными вершинами.
Требования: сложность O(V+E).

_Формат ввода._
v: кол-во вершин (макс. 50000),
n: кол-во ребер (макс. 200000),
n пар реберных вершин,
пара вершин u, w для запроса.

_Формат вывода._
Количество кратчайших путей от u к w.

in | out
--- | ---
4<br>5<br>0 1<br>0 2<br>1 2<br>1 3<br>2 3<br><br>0 3 | 2
###Задача 3. “Города”
Требуется отыскать самый выгодный маршрут между городами.
Требования: время работы O((N+M)logN), где N-количество городов, M-известных дорог между ними.

_Формат входных данных._
Первая строка содержит число N – количество городов.
Вторая строка содержит число M - количество дорог.
Каждая следующая строка содержит описание дороги (откуда, куда, время в пути).
Последняя строка содержит маршрут (откуда и куда нужно доехать).

_Формат выходных данных._
Вывести длину самого выгодного маршрута.

in | out
--- | ---
6<br>9<br>0 3 1<br>0 4 2<br>1 2 7<br>1 3 2<br>1 4 3<br>1 5 3<br>2 5 3<br>3 4 4<br>3 5 6<br>0 2 | 9
###Задача 4. “Пятнашки”
Написать алгоритм для решения игры в “пятнашки”. Решением задачи является приведение к виду:

\- | - | - | - | - | - 
--- | --- | --- | --- | --- | ---
\- |1 | 2 | 3 | 4  | -
\- |5 | 6 | 7 | 8 | -
\- |9 | 10 | 11 | 12 | -
\- |13 | 14 | 15 | 0 | -
- | - | - | - | - | -

где 0 задает пустую ячейку.
Достаточно найти хотя бы какое-то решение. Число перемещений костяшек не обязано быть минимальным.
Формат входных данных
Начальная расстановка.
Формат выходных данных
Если решение существует, то в первой строке выходного файла выведите минимальное число перемещений костяшек, которое нужно сделать, чтобы достичь выигрышной конфигурации, а во второй строке выведите соответствующую последовательность ходов: L означает, что костяшка сдвинулась влево, R – вправо, U – вверх, D – вниз. Если таких последовательностей несколько, то выведите любую из них. Если же выигрышная конфигурация недостижима, то выведите в выходной файл одно число −1.

in | out
--- | ---
1 2 3 4<br>5 6 7 8<br>9 10 11 0<br>13 14 15 12 | 1<br>U
1 2 3 4<br>5 6 7 8<br>9 10 11 12<br>13 15 14 0 | -1
